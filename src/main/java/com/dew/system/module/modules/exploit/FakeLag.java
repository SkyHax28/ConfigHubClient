package com.dew.system.module.modules.exploit;

import com.dew.DewCommon;
import com.dew.system.event.events.*;
import com.dew.system.module.Module;
import com.dew.system.module.ModuleCategory;
import com.dew.system.module.modules.player.Scaffold;
import com.dew.system.settingsvalue.BooleanValue;
import com.dew.system.settingsvalue.NumberValue;
import com.dew.utils.*;
import com.google.common.collect.Queues;
import net.minecraft.client.entity.EntityPlayerSP;
import net.minecraft.client.gui.inventory.GuiContainer;
import net.minecraft.client.multiplayer.WorldClient;
import net.minecraft.client.renderer.GlStateManager;
import net.minecraft.entity.player.EntityPlayer;
import net.minecraft.network.Packet;
import net.minecraft.network.handshake.client.C00Handshake;
import net.minecraft.network.play.client.*;
import net.minecraft.network.play.server.*;
import net.minecraft.network.status.client.C00PacketServerQuery;
import net.minecraft.network.status.client.C01PacketPing;
import net.minecraft.network.status.server.S01PacketPong;
import net.minecraft.util.AxisAlignedBB;
import net.minecraft.util.Vec3;
import org.lwjgl.input.Keyboard;
import org.lwjgl.opengl.GL11;

import java.util.Deque;
import java.util.Iterator;

public class FakeLag extends Module {

    public FakeLag() {
        super("Fake Lag", ModuleCategory.EXPLOIT, Keyboard.KEY_NONE, false, true, true);
    }

    private static final NumberValue allowedDistToEnemy = new NumberValue("Allowed Distance To Enemy", 3.5, 0.0, 6.0, 0.5);
    private static final NumberValue recoilDelay = new NumberValue("Recoil Delay", 200.0, 200.0, 1000.0, 1.0);
    private static final NumberValue restartDelay = new NumberValue("Restart Delay", 200.0, 200.0, 1000.0, 1.0);
    private static final BooleanValue blinkOnAction = new BooleanValue("Blink On Action", true);
    private static final BooleanValue pauseOnNoMove = new BooleanValue("Pause On No Move", true);
    private static final BooleanValue pauseOnChest = new BooleanValue("Pause On Chest", false);

    private final Clock resetTimer = new Clock();
    private final Deque<QueueData> packetQueue = Queues.newArrayDeque();
    private final Deque<PositionData> positions = Queues.newArrayDeque();

    private boolean wasNearEnemy = false;
    private boolean ignoreWholeTick = false;

    private final ModelRenderData renderData = new ModelRenderData(new Vec3(0, 0, 0), DewCommon.rotationManager.getClientYaw(), DewCommon.rotationManager.getClientPitch());

    @Override
    public void onDisable() {
        if (mc.thePlayer != null) {
            blink();
        }
        this.resetState();
    }

    @Override
    public void onWorld(WorldEvent event) {
        blink(false);
        this.resetState();
    }

    private void resetState() {
        packetQueue.clear();
        positions.clear();
        wasNearEnemy = false;
        ignoreWholeTick = false;
    }

    @Override
    public void onSendPacket(SendPacketEvent event) {
        if (event.packet instanceof C00PacketKeepAlive) return;
        if (this.handlePacket(event.packet, true)) {
            event.cancel();
        }
    }

    @Override
    public void onReceivedPacket(ReceivedPacketEvent event) {
        this.handlePacket(event.packet, false);
    }

    private boolean handlePacket(Packet<?> packet, boolean isSend) {
        EntityPlayerSP player = mc.thePlayer;
        if (player == null) return false;

        if (player.isDead || wasNearEnemy || ignoreWholeTick) return false;
        if (pauseOnNoMove.get() && !MovementUtil.isMoving()) {
            blink();
            return false;
        }

        if (player.getHealth() < player.getMaxHealth() && player.hurtTime != 0) {
            blink();
            return false;
        }

        if (DewCommon.moduleManager.getModule(Scaffold.class).isEnabled()) {
            blink();
            return false;
        }

        if (blinkOnAction.get() && packet instanceof C02PacketUseEntity) {
            blink();
            return false;
        }

        if (pauseOnChest.get() && mc.currentScreen instanceof GuiContainer) {
            blink();
            return false;
        }

        if (packet instanceof C00Handshake
                || packet instanceof C00PacketServerQuery
                || packet instanceof C01PacketPing
                || packet instanceof C01PacketChatMessage
                || packet instanceof S01PacketPong) {
            return false;
        }

        if (packet instanceof C0EPacketClickWindow || packet instanceof C0DPacketCloseWindow
                || packet instanceof S08PacketPlayerPosLook
                || packet instanceof C08PacketPlayerBlockPlacement
                || packet instanceof C07PacketPlayerDigging
                || packet instanceof C12PacketUpdateSign
                || packet instanceof C19PacketResourcePackStatus) {
            blink();
            return false;
        }

        if (packet instanceof S12PacketEntityVelocity) {
            if (((S12PacketEntityVelocity) packet).getEntityID() == player.getEntityId()) {
                blink();
                return false;
            }
        }

        if (packet instanceof S27PacketExplosion) {
            S27PacketExplosion explosion = (S27PacketExplosion) packet;
            if (explosion.getX() != 0f || explosion.getY() != 0f || explosion.getZ() != 0f) {
                blink();
                return false;
            }
        }

        if (!resetTimer.hasTimePassed(recoilDelay.get().intValue())) return false;

        if (mc.isSingleplayer() || mc.getCurrentServerData() == null) {
            blink();
            return false;
        }

        if (isSend) {
            if (packet instanceof C03PacketPlayer && ((C03PacketPlayer) packet).isMoving()) {
                synchronized (positions) {
                    positions.add(new PositionData(
                            new Vec3(((C03PacketPlayer) packet).getPositionX(),
                                    ((C03PacketPlayer) packet).getPositionY(),
                                    ((C03PacketPlayer) packet).getPositionZ()),
                            System.currentTimeMillis(),
                            player.renderYawOffset,
                            DewCommon.rotationManager.getClientYaw(),
                            DewCommon.rotationManager.getClientPitch()));
                }
            }

            synchronized (packetQueue) {
                packetQueue.add(new QueueData(packet, System.currentTimeMillis()));
            }

            return true;
        }

        return false;
    }

    private Vec3 getTruePositionEyes(EntityPlayer player) {
        return new Vec3(
                player.posX,
                player.posY + (double) player.getEyeHeight(),
                player.posZ
        );
    }

    private Vec3 getNearestPointBB(Vec3 eye, AxisAlignedBB box) {
        double[] origin = { eye.xCoord, eye.yCoord, eye.zCoord };
        double[] destMins = { box.minX, box.minY, box.minZ };
        double[] destMaxs = { box.maxX, box.maxY, box.maxZ };

        for (int i = 0; i <= 2; i++) {
            if (origin[i] > destMaxs[i]) {
                origin[i] = destMaxs[i];
            } else if (origin[i] < destMins[i]) {
                origin[i] = destMins[i];
            }
        }

        return new Vec3(origin[0], origin[1], origin[2]);
    }

    @Override
    public void onGameLoop(GameLoopEvent event) {
        EntityPlayerSP player = mc.thePlayer;
        WorldClient world = mc.theWorld;

        if (player == null || world == null) return;

        Vec3 playerPos = new Vec3(player.posX, player.posY, player.posZ);
        Vec3 serverPos = positions.isEmpty() ? playerPos : positions.getFirst().pos;

        AxisAlignedBB playerBox = player.getEntityBoundingBox().offset(
                serverPos.xCoord - playerPos.xCoord,
                serverPos.yCoord - playerPos.yCoord,
                serverPos.zCoord - playerPos.zCoord
        );

        wasNearEnemy = false;

        for (EntityPlayer otherPlayer : world.playerEntities) {
            if (otherPlayer == player) continue;

            Vec3 eyes = getTruePositionEyes(otherPlayer);
            Vec3 nearest = getNearestPointBB(eyes, playerBox);
            double distance = eyes.distanceTo(nearest);

            if (distance <= allowedDistToEnemy.get()) {
                blink();
                wasNearEnemy = true;
                return;
            }
        }

        if (player.isDead || player.isUsingItem()) {
            blink();
            return;
        }

        if (!resetTimer.hasTimePassed(recoilDelay.get().intValue())) return;

        handlePackets();
        ignoreWholeTick = false;
    }

    @Override
    public void onRender3D(Render3DEvent event) {
        if (mc.thePlayer == null || positions.isEmpty() || positions.size() < 2 || mc.gameSettings.thirdPersonView == 0) {
            renderData.reset(mc.thePlayer);
            return;
        }

        renderData.update(positions);

        double renderX = mc.getRenderManager().viewerPosX;
        double renderY = mc.getRenderManager().viewerPosY;
        double renderZ = mc.getRenderManager().viewerPosZ;

        float partialTicks = event.partialTicks;

        Iterator<PositionData> it = positions.iterator();

        if (!it.hasNext()) return;
        PositionData first = it.next();

        if (!it.hasNext()) return;
        PositionData second = it.next();

        Vec3 lerpedPos = Lerper.lerpVec3(first.pos, second.pos, partialTicks);

        double x = lerpedPos.xCoord - renderX;
        double y = lerpedPos.yCoord - renderY;
        double z = lerpedPos.zCoord - renderZ;

        AxisAlignedBB bb = new AxisAlignedBB(
                x - 0.4, y, z - 0.4,
                x + 0.4, y + mc.thePlayer.height, z + 0.4
        );

        GlStateManager.pushMatrix();
        GlStateManager.enableBlend();
        GlStateManager.disableTexture2D();
        GlStateManager.disableDepth();
        GlStateManager.depthMask(false);
        GlStateManager.disableLighting();
        GlStateManager.disableCull();
        GlStateManager.tryBlendFuncSeparate(GL11.GL_SRC_ALPHA, GL11.GL_ONE_MINUS_SRC_ALPHA, 1, 0);

        RenderUtil.drawFilledBox(bb, 0.5f, 0f, 1f, 0.15f);

        GlStateManager.enableCull();
        GlStateManager.depthMask(true);
        GlStateManager.enableDepth();
        GlStateManager.enableTexture2D();
        GlStateManager.disableBlend();
        GlStateManager.popMatrix();
    }

    @Override
    public void onRender2D(Render2DEvent event) {
        if (mc.thePlayer == null || positions.isEmpty()) {
            renderData.reset(mc.thePlayer);
            return;
        }

        renderData.update(positions);

        double renderPosX = mc.getRenderManager().viewerPosX;
        double renderPosY = mc.getRenderManager().viewerPosY;
        double renderPosZ = mc.getRenderManager().viewerPosZ;

        for (PositionData data : positions) {
            Vec3 pos = data.getPos();
            GL11.glVertex3d(pos.xCoord - renderPosX, pos.yCoord - renderPosY, pos.zCoord - renderPosZ);
        }
    }

    private void blink() {
        blink(true);
    }

    private void blink(boolean handlePackets) {
        mc.addScheduledTask(() -> {
            if (handlePackets) {
                resetTimer.reset();
            }
            handlePackets(true);
            ignoreWholeTick = true;
        });
    }

    private void handlePackets() {
        handlePackets(false);
    }

    private void handlePackets(boolean clear) {
        long now = System.currentTimeMillis();
        synchronized (packetQueue) {
            packetQueue.removeIf(data -> {
                if (clear || now - data.timestamp >= restartDelay.get().intValue()) {
                    PacketUtil.sendPacketAsSilent(data.packet);
                    return true;
                }
                return false;
            });
        }

        synchronized (positions) {
            positions.removeIf(data -> clear || now - data.timestamp >= restartDelay.get().intValue());
        }
    }

    public String getTag() {
        return Integer.toString(packetQueue.size());
    }

    private static class QueueData {
        final Packet<?> packet;
        final long timestamp;

        QueueData(Packet<?> packet, long timestamp) {
            this.packet = packet;
            this.timestamp = timestamp;
        }
    }

    private static class PositionData {
        final Vec3 pos;
        final long timestamp;
        final float bodyYaw;
        final float yaw;
        final float pitch;

        PositionData(Vec3 pos, long timestamp, float bodyYaw, float yaw, float pitch) {
            this.pos = pos;
            this.timestamp = timestamp;
            this.bodyYaw = bodyYaw;
            this.yaw = yaw;
            this.pitch = pitch;
        }

        public Vec3 getPos() {
            return pos;
        }
    }

    private static class ModelRenderData {
        Vec3 pos;
        float yaw;
        float pitch;

        ModelRenderData(Vec3 pos, float yaw, float pitch) {
            this.pos = pos;
            this.yaw = yaw;
            this.pitch = pitch;
        }

        void reset(EntityPlayerSP player) {
            if (player != null) {
                this.pos = player.getPositionVector();
            }

            this.yaw = DewCommon.rotationManager.getClientYaw();
            this.pitch = DewCommon.rotationManager.getClientPitch();
        }

        void update(Deque<PositionData> positions) {
            PositionData data = positions.getFirst();
            this.pos = Lerper.lerpVec3(this.pos, data.pos, Lerper.deltaTimeNormalized(3));
            this.yaw = Lerper.lerpDoubleDelta(this.yaw, data.yaw, Lerper.deltaTimeNormalized(1));
            this.pitch = Lerper.lerpDoubleDelta(this.pitch, data.pitch, Lerper.deltaTimeNormalized(1));
        }
    }
}